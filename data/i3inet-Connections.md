In **i3inet** , connections -- both the insecure TCP and secure TLS variety -- are somewhat secretive beasts. Users of the **i3http** and **i3sip** modules will generally never deal directly with connection objects or their interfaces at all, in spite of the fact that they are used for the transmission of all HTTP messages and many SIP messages. But some applications -- such as the Session Manager for example -- use the i3inet connection facilities directly, so I'm going to try documenting their design now.

Right off the bat I'll note that the connection-related classes are some of the oldest in the i3inet module, and some of the design decisions would be made differently if I had it all to do over again. But a complete rewrite probably isn't in the cards anytime soon, so let's see what I can do about describing what's there now.

Connection objects come into existence in one of two ways...

  1. The application may _actively create_ them through invocations of the **[i3inet::IConnectionSource](http://i3devfiles/ION-Documentation/core_1.2_systest/pub/gen/doc/i3inet/html/a00056.html)::[get_connection()](http://i3devfiles/ION-Documentation/core_1.2_systest/pub/gen/doc/i3inet/html/a00056.html#a1643617468cc6e0721cad703342d1c82)** method;
  2. The application _passively receive_ them through invocation of the **[i3inet::ConnectionAcceptor](http://i3devfiles/ION-Documentation/core_1.2_systest/pub/gen/doc/i3inet/html/a00028.html)::[accept()](http://i3devfiles/ION-Documentation/core_1.2_systest/pub/gen/doc/i3inet/html/a00028.html#ac017039676f10e2f85d8eb7501b7ea68)** method.



The _logical_ connection object actually consists of two parts -- a user-facing instance of the [**i3inet::impl::Connection**](http://i3devfiles/ION-Documentation/core_1.2_systest/pub/gen/doc/i3inet/html/a00075.html) class, and a "guts" object, which is an instance of either the [**i3inet::impl::TCPConnectionGuts**](http://i3devfiles/ION-Documentation/core_1.2_systest/pub/gen/doc/i3inet/html/a00134.html) class or the [**i3inet::impl::TLSConnectionGuts**](http://i3devfiles/ION-Documentation/core_1.2_systest/pub/gen/doc/i3inet/html/a00140.html) class (both of which are derived from [**i3inet::impl::ConnectionGuts**](http://i3devfiles/ION-Documentation/core_1.2_systest/pub/gen/doc/i3inet/html/a00077.html)) -- as illustrated in the diagram below.

i3inet_Connection

Users of the i3inet module's public API only ever receive (interface) pointers referencing the left-hand "connection" part, and while both parts are reference counted, the pointer _from the guts object back to the connection object is not counted_. Thus, when the connection part's reference count goes to zero, it means that the last _application level_ reference has been released, which signals the guts object to close the actual TCP connection. While the connection object's reference to the guts part is counted, and is released when the that user-facing part goes away, there are also counted references to the guts part held in the proactor's event queue for every outstanding I/O operation -- and there is almost always at least one read operation outstanding for the guts object until it initiates the shutdown sequence. So the guts object stays alive until all of the I/O associated with terminating the connection has completed, at which point its own reference count goes to zero and it can be safely destroyed.

The data coming in from the "low-level" read operations executed by the guts object through its **`m_aioStream`** member (or **`m_sslStream`** member in the case of TLS guts object) is always appended to the user-facing connection object's **`m_buffer`** member, except when the connection shutdown is in progress, since the user-facing object is gone by that point. Thus the availability of data from the connection is _typically_ not affected by whether or not the application code has initiated a read operation on the connection's input stream. However, the user-facing object's **`m_throttle`** member serves to limit the amount of data to be stored in the buffer, so if significant data gets backed up without the application reading, the low-level reads will be suspended, which will eventually cause the socket to start dropping the incoming TCP packets, which will require them to be retransmitted later, negatively affecting the connection's throughput.
