# Overview  
  
[SISR](http://www.w3.org/TR/semantic-interpretation/) (Semantic Interpretation for Speech Recognition) is a W3C Recommendation that defines how to use semantic interpretation tags to describe the meaning of an utterance to a speech application.  SISR tags use [ECMAScript](http://www.ecma-international.org/publications/standards/Ecma-262.htm) objects to describe the meaning of utterances detected from an [SRGS](http://www.w3.org/TR/speech-grammar/) (Speech Recognition Grammar Specification) grammar.  (JavaScript, which is commonly used in web browsers for client-side scripting, is standardized as ECMAScript.  Formal documents refer to JavaScript by its formalized name, ECMAScript.)

In xIC today, SISR interpretation can occur in a few different ways:

  1. For ASR using third party engines, SRGS grammars can include SISR, and the ASR engine will evaluate the SISR and return the evaluated results to our integration.  (I.e. sometimes we do not directly process the SISR tags.)
  2. For DTMF recognitions that are processed on the IC server, we have a limited SISR interpreter that the RecoSubsystem uses to evaluate any SISR tags.  Since DTMF grammars are generally simple, the limited SISR interpreter has not caused significant support issues.
  3. For , starting in 4.0 SU3, the same SISR interpreter used for DTMF recognitions is used for .  The limited SISR interpreter is likely to cause more significant support issues, and the fact that only the RecoSubsystem on the IC server can interpret SISR will become a scalability issue for grammars with complex SISR tags.



The first use case won't change, and third party ASR engines will continue to process SISR tags using their own engine.  When recognitions are handled by media servers, the SISR tags should be evaluated on the media servers before the recognition result is returned to the RecoSubsystem.  This interpretation should be more advanced and more fully support ECMAScript, especially in terms of supporting user-defined functions and builtin ECMAScript functions.

# Use Cases

The SISR Interpreter is intended for use with SRGS because SISR is defined in terms of using SRGS recognition results.  Any use case of SISR will be derived from how SISR is used with SRGS.  The [SISR](http://www.w3.org/TR/semantic-interpretation/) specification provides the requirements for how inputs will be converted into outputs.  General purpose JavaScript interpretation is handled by i3javascript, so this library only needs to worry about interpreting [SISR](http://www.w3.org/TR/semantic-interpretation/) tags.

While designing the i3sisr interface, it is helpful to consider what types of clients might use i3sisr:

  1. The primary type of client is an ASR or DTMF engine that needs to have SISR tags evaluated from an SRGS grammar.  Examples: after candidate recognition results are generated by i3asr (ISR) or i3dtmf, the new ION SISR interpreter (i3sisr) would be invoked to interpret any SISR tags and concatenate all the tokens.
  2. A secondary type of client that might be created down the road is a tuning application.  The client may have some combination of SRGS grammar files, WAV files, and raw recognition results.  Ultimately, this use case isn't much different than the first one because the client would need to provide unevaluated SISR tags to i3sisr.  The main difference is that there could be a large batch of recognitions that need to be evaluated ASAP that use the same grammars.  Compiling SISR tags may be more important for performance in this scenario.



# Design

At a high level, the ION SISR Interpreter (i3sisr) will receive an i3speech::Transcription as the input.  (This already includes references to every i3speech::srgs::GrammarInfo object that is needed, so global tags are available for parsing.)  The interpreter then processes the SISR tags and result tokens to create an i3speech::Interpretation as the output.  For simple SISR tags, the process of evaluating the SISR tags may use an SISR interpreter based on the one used by the RecoSubsystem (but ported to ION).  For complex SISR tags (ex. functions and loops), a more advanced ECMAScript engine will be used: ION/core/i3javascript.

This design (providing an i3speech::Transcription) will satisfy all clients discussed in the Use Cases section:

  1. i3asr and i3dtmf are already creating i3speech::Transcription objects.
  2. A tuning application will need to create something equivalent to a flat parse list.  The i3speech::Transcription is an abstraction of the flat parse list, so it is a reasonable interface for these types of clients to use and already has Composers that should allow for the convenient construction of an i3speech::Transcription.



### Design Questions 

  1. What class and how often will i3javascript Context objects get created?  Once per caller/session (meaning that a global scope is shared between applications - VoiceXML and SISR)?  Or once per grammar (meaning that JavaScript Values will occasionally need to be shared between Contexts, which requires additional copying, but global scopes for grammars are evaluated just once)?
  2. Does the overhead of i3javascript justify porting the RecoSubsystem SISR interpreter to ION?  It certainly makes sense to handle trivial cases like SISR String Literals without i3javascript (where ECMAScript interpretation isn't even needed).  Grammars with similarly basic scripts (simple assignment operations to out) can be done fairly easily without i3javascript, but hybrid cases where some tags can be done by ourselves and some tags require i3javascript would be more tricky because of the need to translate to and from i3javascript's interpreter.  If a ported interpreter handles intermediately complex scripts, there's a risk that we'd generate inconsistent results for similar tags.  For example, the precision and rounding of doubles may vary depending on whether the script was deemed complex (i3javascript) or intermediate (ported interpreter).
  3. Should there be a caching mechanism to store compiled representations of scripts (tags), and how would the caching mechanism work in terms of determining when scripts should be purged and which ones?
  4. Need to investigate what protections we have against infinite loops.  SpiderMonkey has a JS_SetOperationCallback where an application can terminate a script that takes too much time, and we need to ensure that we take advantage of that to prevent excessive CPU usage on the media servers.


